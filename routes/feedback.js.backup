const express = require('express');
const { body, validationResult } = require('express-validator');
const { pool } = require('../config/database');
const { authenticateStoreManager, optionalAuth } = require('../middleware/auth');

const router = express.Router();

// Submit feedback
router.post('/', optionalAuth, [
  body('store_id').isInt().withMessage('Valid store ID is required'),
  body('overall_rating').isInt({ min: 1, max: 5 }).withMessage('Overall rating must be between 1 and 5'),
  body('service_rating').optional().isInt({ min: 1, max: 5 }).withMessage('Service rating must be between 1 and 5'),
  body('product_rating').optional().isInt({ min: 1, max: 5 }).withMessage('Product rating must be between 1 and 5'),
  body('cleanliness_rating').optional().isInt({ min: 1, max: 5 }).withMessage('Cleanliness rating must be between 1 and 5'),
  body('value_rating').optional().isInt({ min: 1, max: 5 }).withMessage('Value rating must be between 1 and 5'),
  body('comments').optional().trim().isLength({ max: 1000 }).withMessage('Comments must be less than 1000 characters')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation errors',
        errors: errors.array()
      });
    }

    const {
      store_id, overall_rating, service_rating, product_rating,
      cleanliness_rating, value_rating, comments
    } = req.body;

    // Verify store exists
    const [stores] = await pool.execute(
      'SELECT id FROM stores WHERE id = ?',
      [store_id]
    );

    if (stores.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Store not found'
      });
    }

    // Insert feedback
    const [result] = await pool.execute(
      `INSERT INTO feedback (
        store_id, customer_id, overall_rating, service_rating, product_rating,
        cleanliness_rating, value_rating, comments
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        store_id,
        req.user?.customerId || null,
        overall_rating,
        service_rating || null,
        product_rating || null,
        cleanliness_rating || null,
        value_rating || null,
        comments || null
      ]
    );

    const feedbackId = result.insertId;

    // Get the created feedback
    const [feedback] = await pool.execute(
      'SELECT * FROM feedback WHERE id = ?',
      [feedbackId]
    );

    res.status(201).json({
      success: true,
      message: 'Feedback submitted successfully',
      data: feedback[0]
    });

  } catch (error) {
    console.error('Submit feedback error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to submit feedback'
    });
  }
});

// Get feedback for a store (store manager)
router.get('/store/:storeId', async (req, res) => {
  try {
    const { storeId } = req.params;
    const { page = 1, limit = 10, rating_filter } = req.query;

    // Verify store ownership
    if (parseInt(storeId) !== req.user.storeId) {
      return res.status(403).json({
        success: false,
        message: 'Access denied'
      });
    }

    const offset = (page - 1) * limit;

    let query = `
      SELECT f.*, c.name as customer_name, c.email as customer_email
      FROM feedback f
      LEFT JOIN customers c ON f.customer_id = c.id
      WHERE f.store_id = ?
    `;
    const queryParams = [storeId];

    if (rating_filter) {
      query += ' AND f.overall_rating = ?';
      queryParams.push(parseInt(rating_filter));
    }

    query += ' ORDER BY f.created_at DESC LIMIT ? OFFSET ?';
    queryParams.push(parseInt(limit), offset);

    const [feedback] = await pool.execute(query, queryParams);

    // Get total count
    let countQuery = 'SELECT COUNT(*) as total FROM feedback WHERE store_id = ?';
    const countParams = [storeId];

    if (rating_filter) {
      countQuery += ' AND overall_rating = ?';
      countParams.push(parseInt(rating_filter));
    }

    const [countResult] = await pool.execute(countQuery, countParams);
    const total = countResult[0].total;

    res.json({
      success: true,
      data: {
        feedback,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      }
    });

  } catch (error) {
    console.error('Get feedback error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch feedback'
    });
  }
});

// Get feedback summary for a store
router.get('/store/:storeId/summary', authenticateStoreManager, async (req, res) => {
  try {
    const { storeId } = req.params;

    // Verify store ownership
    if (parseInt(storeId) !== req.user.storeId) {
      return res.status(403).json({
        success: false,
        message: 'Access denied'
      });
    }

    // Get overall statistics
    const [overallStats] = await pool.execute(
      `SELECT 
        COUNT(*) as total_feedback,
        AVG(overall_rating) as avg_overall_rating,
        AVG(service_rating) as avg_service_rating,
        AVG(product_rating) as avg_product_rating,
        AVG(cleanliness_rating) as avg_cleanliness_rating,
        AVG(value_rating) as avg_value_rating
      FROM feedback 
      WHERE store_id = ?`,
      [storeId]
    );

    // Get rating distribution
    const [ratingDistribution] = await pool.execute(
      `SELECT 
        overall_rating,
        COUNT(*) as count
      FROM feedback 
      WHERE store_id = ? 
      GROUP BY overall_rating 
      ORDER BY overall_rating DESC`,
      [storeId]
    );

    // Get recent feedback (last 7 days)
    const [recentFeedback] = await pool.execute(
      `SELECT 
        COUNT(*) as count,
        AVG(overall_rating) as avg_rating
      FROM feedback 
      WHERE store_id = ? 
      AND created_at >= DATE_SUB(NOW(), INTERVAL 7 DAY)`,
      [storeId]
    );

    // Get feedback with comments
    const [feedbackWithComments] = await pool.execute(
      `SELECT 
        COUNT(*) as count
      FROM feedback 
      WHERE store_id = ? 
      AND comments IS NOT NULL 
      AND comments != ''`,
      [storeId]
    );

    res.json({
      success: true,
      data: {
        overall: overallStats[0],
        ratingDistribution,
        recent: recentFeedback[0],
        withComments: feedbackWithComments[0]
      }
    });

  } catch (error) {
    console.error('Get feedback summary error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch feedback summary'
    });
  }
});

// Get feedback by customer (if authenticated)
router.get('/my-feedback', optionalAuth, async (req, res) => {
  try {
    if (!req.user || req.user.role !== 'customer') {
      return res.status(401).json({
        success: false,
        message: 'Customer authentication required'
      });
    }

    const { page = 1, limit = 10 } = req.query;
    const offset = (page - 1) * limit;

    const [feedback] = await pool.execute(
      `SELECT f.*, s.name as store_name
       FROM feedback f
       JOIN stores s ON f.store_id = s.id
       WHERE f.customer_id = ?
       ORDER BY f.created_at DESC
       LIMIT ? OFFSET ?`,
      [req.user.customerId, parseInt(limit), offset]
    );

    // Get total count
    const [countResult] = await pool.execute(
      'SELECT COUNT(*) as total FROM feedback WHERE customer_id = ?',
      [req.user.customerId]
    );
    const total = countResult[0].total;

    res.json({
      success: true,
      data: {
        feedback,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          pages: Math.ceil(total / limit)
        }
      }
    });

  } catch (error) {
    console.error('Get my feedback error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch feedback'
    });
  }
});

// Delete feedback (store manager only)
router.delete('/:feedbackId', authenticateStoreManager, async (req, res) => {
  try {
    const { feedbackId } = req.params;

    // Verify feedback belongs to the store
    const [feedback] = await pool.execute(
      'SELECT id FROM feedback WHERE id = ? AND store_id = ?',
      [feedbackId, req.user.storeId]
    );

    if (feedback.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Feedback not found'
      });
    }

    await pool.execute(
      'DELETE FROM feedback WHERE id = ?',
      [feedbackId]
    );

    res.json({
      success: true,
      message: 'Feedback deleted successfully'
    });

  } catch (error) {
    console.error('Delete feedback error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete feedback'
    });
  }
});

// Export feedback to Excel (store manager)
router.get('/store/:storeId/export', authenticateStoreManager, async (req, res) => {
  try {
    const { storeId } = req.params;
    const { start_date, end_date } = req.query;

    // Verify store ownership
    if (parseInt(storeId) !== req.user.storeId) {
      return res.status(403).json({
        success: false,
        message: 'Access denied'
      });
    }

    let query = `
      SELECT 
        f.id,
        f.overall_rating,
        f.service_rating,
        f.product_rating,
        f.cleanliness_rating,
        f.value_rating,
        f.comments,
        f.created_at,
        c.name as customer_name,
        c.email as customer_email,
        c.phone as customer_phone
      FROM feedback f
      LEFT JOIN customers c ON f.customer_id = c.id
      WHERE f.store_id = ?
    `;
    const queryParams = [storeId];

    if (start_date) {
      query += ' AND DATE(f.created_at) >= ?';
      queryParams.push(start_date);
    }
    if (end_date) {
      query += ' AND DATE(f.created_at) <= ?';
      queryParams.push(end_date);
    }

    query += ' ORDER BY f.created_at DESC';

    const [feedback] = await pool.execute(query, queryParams);

    // Format data for Excel
    const excelData = feedback.map(f => ({
      'Feedback ID': f.id,
      'Overall Rating': f.overall_rating,
      'Service Rating': f.service_rating || 'N/A',
      'Product Rating': f.product_rating || 'N/A',
      'Cleanliness Rating': f.cleanliness_rating || 'N/A',
      'Value Rating': f.value_rating || 'N/A',
      'Comments': f.comments || 'N/A',
      'Customer Name': f.customer_name || 'Anonymous',
      'Customer Email': f.customer_email || 'N/A',
      'Customer Phone': f.customer_phone || 'N/A',
      'Date': new Date(f.created_at).toLocaleDateString()
    }));

    res.json({
      success: true,
      message: 'Feedback data ready for export',
      data: excelData
    });

  } catch (error) {
    console.error('Export feedback error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to export feedback'
    });
  }
});

module.exports = router; 